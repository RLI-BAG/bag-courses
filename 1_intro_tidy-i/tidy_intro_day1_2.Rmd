---
title: "Tidyverse Intro I"
author: ["Antoine & Nicolas", "cynkra GmbH"]
date: "January 25, 2022"
output:
  cynkradown::cynkra_slides:
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    seal: true
fontsize: 10pt
lang: english
font: frutiger
wide: false
colorlinks: false
logo: true
header-includes:
  - \usepackage{parskip}
---

<style type="text/css">
.remark-code {
    font-size: 12px;
}
.font17 {
    font-size: 17px;
}
.font14 {
    font-size: 14px;
}
</style>

# Tidyverse Intro I-2

* Filtering data

---

# Filter rows with `filter()`

* Filter a data frame with one or several filtering expressions
* Improved version of `subset()` base function

```{r, echo = FALSE}
options(tidyverse.quiet = TRUE)
```


```{r}
library(tidyverse)
library(pixarfilms)
# filter(<data frame>, <filtering expressions>)
filter(pixar_films, run_time == 100, film_rating == "G")
```

???
`filter()` allows you to subset observations based on their values. The first
argument is the name of the data frame. The second and subsequent arguments
are the expressions that filter the data frame. For example, we can select
all flights on January 1st with:

---

# Filter rows with `filter()`

* forgetting to load {dplyr} triggers surprising error
* base R has a different `filter()` function!

```{r, echo = FALSE, include= FALSE}
detach("package:dplyr")
```

```{r, error = TRUE}
filter(pixar_films, run_time == 100, film_rating == "G")
```

```{r, echo = FALSE, include= FALSE}
library(dplyr)
```

---

# Filter rows with `filter()`

* Don't forget to assign the result!
* tidyverse functions never modify the input in place

```{r}
film_subset <- filter(pixar_films, run_time == 100, film_rating == "G")
```

???
When you run that line of code, dplyr executes the filtering operation and
returns a new data frame. dplyr functions never modify their inputs, so if
you want to save the result, you'll need to use the assignment operator,
`<-`

---

# Filter rows with `filter()`

* Use `(x <- ...)` to print and assign at the same time  

```{r}
(film_subset <- filter(pixar_films, run_time == 100, film_rating == "G"))
```

???
R either prints out the results, or saves them to a variable. If you want to
do both, you can wrap the assignment in parentheses:

---

# Comparison operators

What is happening here ?

```{r, error = TRUE}
filter(pixar_films, run_time = 100)
```

---

# Comparison operators

* `=` is used to set arguments
* `==` is used to test equality
* don't panic and read the error messages

```{r}
filter(pixar_films, run_time <= 92)
```

???
When you're starting out with R, the easiest mistake to make is to use `=`
instead of `==` when testing for equality. When this happens you'll get an
informative error:

---

# Comparison operators

* All comparison operators : `>`, `>=`, `<`, `<=`, `!=`, `==`

```{r}
filter(pixar_films, run_time <= 92)
```

???
To use filtering effectively, you have to know how to select the observations
that you want using the comparison operators. R provides the standard suite:
`>`, `>=`, `<`, `<=`, `!=` (not equal), and `==` (equal).

---

# Comparison operators

They work with character or date columns too!

```{r}
filter(pixar_films, film > "U")
subset(pixar_films, release_date < "2000-01-01")
```

---

# Comparison operators

What is happening here ?

```{r}
filter(pixar_films, number < 2)
```

???
the `number` column is stored as character! So our comparison is alhabetical

---

# Floating point numbers

What is happening here ?

```{r}
sqrt(2) ^ 2 == 2
1/49 * 49 == 1
```

???
There's another common problem you might encounter when using `==`: floating
point numbers. These results might surprise you!

# Floating point numbers

stick with rounded numbers, or use `near()`

```{r}
near(sqrt(2) ^ 2,  2)
near(1 / 49 * 49, 1)
```

???
Computers use finite precision arithmetic (they obviously can't store an
infinite number of digits!) so remember that every number you see is an
approximation. Instead of relying on `==`, use `near()`:

near(sqrt(2) ^ 2,  2)
near(1 / 49 * 49, 1)

---

# Logical operators

* `&` : "and"
* `|` : "or"
* `!` : "not"

---

# Logical operators

* `&` : "and"
* `|` : "or"
* `!` : "not"

```{r}
# Same thing:
filter(pixar_films, run_time == 100, film_rating != "PG")

filter(pixar_films, run_time == 100 & film_rating != "PG")
```

???
Multiple arguments to `filter()` are combined with "and": every expression
must be true in order for a row to be included in the output. For other types
of combinations, you'll need to use Boolean operators yourself: `&` is "and",
`|` is "or", and `!` is "not".

---

# Logical operators

* `&` : "and"
* `|` : "or"
* `!` : "not"

```{r}
filter(pixar_films, film == "Toy Story" | run_time == "100")
```

---

# Logical operators

What is happening here ?

```{r, error = TRUE}
filter(pixar_films, film == "Toy Story" | "Toy Story 2")
filter(pixar_films, run_time == 81 | 82)
```

???
The order of operations doesn't work like English. You can't write
`filter(pixar_films, film == 81 | 82)`, which you might literally translate into
"finds all films with a run time of 81 or 82". Instead it finds
all months that equal `81 | 82`, an expression that evaluates to `TRUE`. In a
numeric context (like here), `TRUE` becomes one, so this finds all films with
a run_time of `1`, and there are none!

---

# Logical operators

* `"Toy Story" | "Toy Story 2"` fails
* ` 81 | 82` returns `TRUE`

```{r}
# this works
filter(pixar_films, film == "Toy Story" | film == "Toy Story 2")
# this is better
filter(pixar_films, film %in% c("Toy Story", "Toy Story 2"))
```

???
A useful short-hand for this problem is `x %in% y`. This will select every
row where `x` is one of the values in `y`. We could use it to rewrite the
code above:

---

# De Morgan's law

* simplify conditions when you can!
* `!(x & y)` is the same as `!x | !y`
* `!(x | y)` is the same as `!x & !y`

```{r}
filter(pixar_films, !(run_time < 93 | release_date > "2000-01-01"))
filter(pixar_films, run_time >= 93, release_date <= "2000-01-01")
```

???
Sometimes you can simplify complicated subsetting by remembering De Morgan's
law: `!(x & y)` is the same as `!x | !y`, and `!(x | y)` is the same as `!x &
!y`.

---

# Missing values

* R has a special value to say "I don't know" : `NA` (Not available) 
* They're a common occurence in datasets
* Watch out for "fake" NAs!

```{r}
tail(pixar_films)
```

???
It's common in "messy" data to find "NA" strings, it's often a symptom of
a failure at reading or writing the data properly.

---

# Missing values

What do these return ?

```{r, eval = FALSE}
NA > 5
10 == NA
NA + 10
NA / 2
NA == NA
```

???
One important feature of R that can make comparison tricky are missing
values, or `NA`s ("not availables"). `NA` represents an unknown value so
missing values are "contagious": almost any operation involving an unknown
value will also be unknown.
The last one might seem confusing, but if you have two unknown values, are they
equal ? you don't know!

---

# Missing values

What do these return ?

```{r, eval = TRUE}
NA > 5
10 == NA
NA + 10
NA / 2
NA == NA
```

---

# Missing values

```{r}
# Let x be Mary's age. We don't know how old she is.
x <- NA

# Let y be John's age. We don't know how old he is.
y <- NA

# Are John and Mary the same age?
x == y
# We don't know!
```

---

# Missing values

* To determine if a value is missing, use `is.na()`
* We often use `!is.na()` in filter to remove missing values

```{r}
is.na(c(NA, "NA"))

filter(pixar_films, film == NA)

filter(pixar_films, is.na(film))
```

---

# Missing values

* `filter()` only includes rows where the condition is `TRUE`;
* excludes both `FALSE` and `NA` values. 
* preserve them explicitly

```{r}
filter(pixar_films, run_time < 95 | is.na(run_time))
```


---

# Missing values

What do these return ?

```{r, eval = FALSE}
NA ^ 0
NA | TRUE
FALSE & NA
NA * 0
```

---

# Missing values

What do these return ?

```{r}
NA ^ 0
NA | TRUE
FALSE & NA
NA * 0
```

---

# Useful helpers

* On numeric: `between()`

```{r}
# same result!
filter(pixar_films, run_time >= 91, run_time <= 94)
filter(pixar_films, between(run_time, 91, 94))
```

---

# Useful helpers

* On char: `str_starts()`, `str_ends()`, `str_detect()`
* from {stringr} package loaded with tidyverse

```{r}
filter(pixar_films, str_starts(film, "Toy"))

filter(pixar_films, str_detect(film, "ory"))
```

# Useful helpers

* On date: `year()`, `month()`, `day()`
* from {lubridate} package NOT loaded with tidyverse

```{r}
library(lubridate)

filter(pixar_films, year(release_date) == 1998)

filter(pixar_films, between(release_date, as_date("1998-01-01"), as_date("1998-12-31")))

filter(pixar_films, release_date >= "1998-01-01", release_date <= "1998-12-31")
```

---

# Exercises

1.  Find all films that

    1. Are rated "PG"
    2. Had a run time below 95 
    3. Had a rating of "N/A" or "Not Rated"
    4. Were released after and including year 2020 
    5. Have a missing name (`film` column) or `run_time`
    6. Were released after and including year 2020 with name not missing
    7. Are a first sequel (the name ends with "2")
    8. Were released between "2018-06-12" and  "2020-04-27" using `>=` and `<=`
    9. The same, using `between()` and `lubridate::as_date()`
